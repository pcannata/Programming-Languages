Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> LINUX
Rule 2     start -> cpu
Rule 3     start -> all
Rule 4     start -> empty
Rule 5     start -> time
Rule 6     time -> INTEGER : INTEGER : INTEGER AMPM
Rule 7     cpu -> time CPU
Rule 8     all -> time ALL
Rule 9     empty -> <empty>

Terminals, with rules where they appear

:                    : 6 6
ALL                  : 8
AMPM                 : 6
CPU                  : 7
INTEGER              : 6 6 6
LINUX                : 1
error                : 

Nonterminals, with rules where they appear

all                  : 3
cpu                  : 2
empty                : 4
start                : 0
time                 : 5 7 8

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . LINUX
    (2) start -> . cpu
    (3) start -> . all
    (4) start -> . empty
    (5) start -> . time
    (7) cpu -> . time CPU
    (8) all -> . time ALL
    (9) empty -> .
    (6) time -> . INTEGER : INTEGER : INTEGER AMPM

    LINUX           shift and go to state 2
    $end            reduce using rule 9 (empty -> .)
    INTEGER         shift and go to state 5

    start                          shift and go to state 3
    all                            shift and go to state 1
    cpu                            shift and go to state 6
    empty                          shift and go to state 7
    time                           shift and go to state 4

state 1

    (3) start -> all .

    $end            reduce using rule 3 (start -> all .)


state 2

    (1) start -> LINUX .

    $end            reduce using rule 1 (start -> LINUX .)


state 3

    (0) S' -> start .



state 4

    (5) start -> time .
    (7) cpu -> time . CPU
    (8) all -> time . ALL

    $end            reduce using rule 5 (start -> time .)
    CPU             shift and go to state 9
    ALL             shift and go to state 8


state 5

    (6) time -> INTEGER . : INTEGER : INTEGER AMPM

    :               shift and go to state 10


state 6

    (2) start -> cpu .

    $end            reduce using rule 2 (start -> cpu .)


state 7

    (4) start -> empty .

    $end            reduce using rule 4 (start -> empty .)


state 8

    (8) all -> time ALL .

    $end            reduce using rule 8 (all -> time ALL .)


state 9

    (7) cpu -> time CPU .

    $end            reduce using rule 7 (cpu -> time CPU .)


state 10

    (6) time -> INTEGER : . INTEGER : INTEGER AMPM

    INTEGER         shift and go to state 11


state 11

    (6) time -> INTEGER : INTEGER . : INTEGER AMPM

    :               shift and go to state 12


state 12

    (6) time -> INTEGER : INTEGER : . INTEGER AMPM

    INTEGER         shift and go to state 13


state 13

    (6) time -> INTEGER : INTEGER : INTEGER . AMPM

    AMPM            shift and go to state 14


state 14

    (6) time -> INTEGER : INTEGER : INTEGER AMPM .

    CPU             reduce using rule 6 (time -> INTEGER : INTEGER : INTEGER AMPM .)
    ALL             reduce using rule 6 (time -> INTEGER : INTEGER : INTEGER AMPM .)
    $end            reduce using rule 6 (time -> INTEGER : INTEGER : INTEGER AMPM .)

